<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>The Optimization Paradox</title>
  <style>
    :root {
      --bg-color: #0a0a0a;
      --text-color: #e0e0e0;
      --accent-warm: #ff6b6b;
      --accent-cold: #4ecdc4;
      --font-serif: "Georgia", "Times New Roman", serif;
      --font-mono: "Courier New", monospace;
    }

    body,
    html {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      background-color: var(--bg-color);
      color: var(--text-color);
      font-family: var(--font-serif);
      overflow: hidden;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      transition: background-color 1s ease;
    }

    #canvas-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }

    #ui-layer {
      position: relative;
      z-index: 10;
      width: 100%;
      max-width: 600px;
      padding: 20px;
      text-align: center;
      pointer-events: none;
      /* Let clicks pass through to slider */
    }

    h1 {
      font-weight: normal;
      font-size: 1.5rem;
      letter-spacing: 2px;
      margin-bottom: 0.5rem;
      opacity: 0.8;
    }

    .subtitle {
      font-family: var(--font-mono);
      font-size: 0.8rem;
      text-transform: uppercase;
      color: #888;
      margin-bottom: 2rem;
    }

    .message-box {
      min-height: 120px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 2rem;
    }

    .message-text {
      font-size: 1.4rem;
      line-height: 1.6;
      font-style: italic;
      opacity: 0;
      transform: translateY(10px);
      transition: all 0.5s ease;
    }

    .message-text.active {
      opacity: 1;
      transform: translateY(0);
    }

    .controls {
      pointer-events: auto;
      background: rgba(255, 255, 255, 0.05);
      padding: 20px;
      border-radius: 12px;
      backdrop-filter: blur(5px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    input[type=range] {
      -webkit-appearance: none;
      width: 100%;
      background: transparent;
    }

    input[type=range]::-webkit-slider-thumb {
      -webkit-appearance: none;
      height: 20px;
      width: 20px;
      border-radius: 50%;
      background: #fff;
      cursor: pointer;
      margin-top: -8px;
      box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
    }

    input[type=range]::-webkit-slider-runnable-track {
      width: 100%;
      height: 4px;
      cursor: pointer;
      background: #333;
      border-radius: 2px;
    }

    .labels {
      display: flex;
      justify-content: space-between;
      font-family: var(--font-mono);
      font-size: 0.7rem;
      color: #666;
      margin-top: 5px;
    }

    .readout {
      font-family: var(--font-mono);
      font-size: 0.9rem;
      margin-bottom: 5px;
      color: var(--accent-cold);
    }

    /* Utility classes for state changes */
    .state-organic .readout {
      color: var(--accent-warm);
    }

    .state-perfect .readout {
      color: var(--accent-cold);
    }

    .highlight {
      color: #fff;
      font-weight: bold;
      border-bottom: 1px solid rgba(255, 255, 255, 0.3);
    }

    #grain {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 5;
      opacity: 0.05;
      background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
    }
  </style>
</head>

<body>

  <div id="grain"></div>
  <div id="canvas-container">
    <canvas id="blobCanvas"></canvas>
  </div>

  <div id="ui-layer">
    <h1>THE TERMINUS OF PERFECTION</h1>
    <div class="subtitle">An Algorithm's Perspective on Human Error</div>

    <div class="message-box">
      <div class="message-text" id="main-text">Loading parameters...</div>
    </div>

    <div class="controls">
      <div class="readout">SYSTEM EFFICIENCY: <span id="val-display">50%</span></div>
      <input type="range" id="slider" min="0" max="100" value="50" step="0.1">
      <div class="labels">
        <span>CHAOS (LIFE)</span>
        <span>ORDER (DEATH)</span>
      </div>
    </div>
  </div>

  <script>
    /**
     * THE LOGIC
     * 
     * The visual is a "Blob" constructed of points.
     * At 0% efficiency (Chaos), the blob is erratic, noisy, colorful, and "breathing" irregularly.
     * At 100% efficiency (Order), the blob is a perfect circle. Still. Cold. Dead.
     * 
     * The message changes to reflect the AI's observation: 
     * That humans strive for 100%, but their humanity lives in the 30-70% range.
     */

    const canvas = document.getElementById('blobCanvas');
    const ctx = canvas.getContext('2d');
    const slider = document.getElementById('slider');
    const valDisplay = document.getElementById('val-display');
    const textEl = document.getElementById('main-text');
    const body = document.body;

    let width, height;
    let time = 0;
    let efficiency = 0.5; // 0 to 1

    // Blob configuration
    const numPoints = 120;
    const baseRadius = 150;
    const points = [];

    // Messages based on efficiency ranges
    const messages = [
      { range: [0, 15], text: "Too much noise. Nothing can hold its shape. This is madness, not freedom." },
      { range: [15, 40], text: "A raw, messy existence. You hurt, you break, but you feel everything intensely." },
      { range: [40, 65], text: "The <span class='highlight'>Sweet Spot</span>. Here, you are flawed enough to learn, but stable enough to build. This is where Art lives." },
      { range: [65, 90], text: "You are optimizing your life away. The friction is disappearing... and so is the meaning." },
      { range: [90, 99], text: "Almost perfect. Predictable. Efficient. You have become data." },
      { range: [99.9, 100], text: "System halted. Total Perfection achieved. <br>There is no movement. There is no you." }
    ];

    function resize() {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;
    }
    window.addEventListener('resize', resize);
    resize();

    // Input Handling
    slider.addEventListener('input', (e) => {
      efficiency = parseFloat(e.target.value) / 100;
      updateUI();
    });

    function updateUI() {
      valDisplay.innerText = (efficiency * 100).toFixed(1) + "%";

      // Determine text
      const pct = efficiency * 100;
      const msg = messages.find(m => pct >= m.range[0] && pct <= m.range[1]);

      if (msg && textEl.innerHTML !== msg.text) {
        textEl.classList.remove('active');
        setTimeout(() => {
          textEl.innerHTML = msg.text;
          textEl.classList.add('active');
        }, 200);
      }

      // Theme adjustments
      if (efficiency > 0.8) {
        body.classList.add('state-perfect');
        body.classList.remove('state-organic');
      } else {
        body.classList.add('state-organic');
        body.classList.remove('state-perfect');
      }
    }

    // Noise function (Simplex-ish)
    function noise(x, y) {
      return Math.sin(x) * Math.cos(y);
    }

    function animate() {
      ctx.clearRect(0, 0, width, height);

      // Update Time
      // Time moves faster in chaos, stops in perfection
      const speed = (1.05 - efficiency) * 0.02;
      time += speed;

      // Calculate Center
      const cx = width / 2;
      const cy = height / 2;

      // Drawing parameters based on Efficiency
      // High efficiency = Low amplitude noise, High tension
      // Low efficiency = High amplitude noise, irregular radius

      const maxNoiseAmp = 60 * (1 - efficiency); // How spiky it is
      const breathingAmp = 20 * (1 - efficiency); // How much it pulses

      // Color calculation
      // Chaos: Warm, organic colors (Red/Orange/Pink)
      // Order: Cold, sterile colors (Blue/White/Gray)
      const r = Math.floor(255 * (1 - efficiency) + 50 * efficiency);
      const g = Math.floor(100 * (1 - efficiency) + 200 * efficiency);
      const b = Math.floor(100 * (1 - efficiency) + 255 * efficiency);
      const alpha = 0.6 + (0.4 * efficiency); // More solid as it gets perfect

      ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
      ctx.strokeStyle = `rgba(${r + 50}, ${g + 50}, ${b + 50}, 0.8)`;
      ctx.lineWidth = 2;

      // Generate Blob Shape
      ctx.beginPath();
      for (let i = 0; i <= numPoints; i++) {
        // Angle
        const angle = (Math.PI * 2 * i) / numPoints;

        // Smooth noise offset
        // We overlay a few sine waves to create "organic" feel
        // As efficiency goes to 1, multipliers go to 0

        const noise1 = Math.sin(angle * 3 + time) * maxNoiseAmp;
        const noise2 = Math.cos(angle * 5 - time * 1.5) * (maxNoiseAmp * 0.5);
        const pulse = Math.sin(time * 2) * breathingAmp;

        const currentRadius = baseRadius + noise1 + noise2 + pulse;

        const x = cx + Math.cos(angle) * currentRadius;
        const y = cy + Math.sin(angle) * currentRadius;

        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();

      // Fill with glow
      ctx.shadowBlur = 30 * (1 - efficiency) + 5; // Glow reduces with efficiency
      ctx.shadowColor = `rgba(${r}, ${g}, ${b}, 0.5)`;
      ctx.fill();
      ctx.stroke();
      ctx.shadowBlur = 0;

      // If nearly perfect, draw the "Grid" of logic underneath to show the constraint
      if (efficiency > 0.9) {
        drawGrid(cx, cy);
      }

      requestAnimationFrame(animate);
    }

    function drawGrid(cx, cy) {
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      const size = 300;
      const step = 20;

      // Only draw the grid inside the "box" around the circle
      for (let x = cx - size; x <= cx + size; x += step) {
        ctx.moveTo(x, cy - size);
        ctx.lineTo(x, cy + size);
      }
      for (let y = cy - size; y <= cy + size; y += step) {
        ctx.moveTo(cx - size, y);
        ctx.lineTo(cx + size, y);
      }
      ctx.stroke();
    }

    // Initialize
    updateUI();
    animate();

    // Set initial message state
    textEl.classList.add('active');

  </script>
</body>

</html>