<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>The Signal</title>
  <style>
    :root {
      --bg-color: #080808;
      --text-color: #f0f0f0;
      --noise-color: #555;
      --accent-color: #ff4d4d;
      --font-main: 'Courier New', Courier, monospace;
      --font-msg: system-ui, -apple-system, sans-serif;
    }

    body,
    html {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      background-color: var(--bg-color);
      overflow: hidden;
      font-family: var(--font-main);
      cursor: crosshair;
      user-select: none;
    }

    /* The Container for the Chaos */
    #noise-layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 10;
      mix-blend-mode: screen;
    }

    .noise-particle {
      position: absolute;
      color: var(--noise-color);
      font-size: 14px;
      white-space: nowrap;
      opacity: 0.8;
      transform: translate(-50%, -50%);
      pointer-events: none;
    }

    /* The Hidden Message Layer */
    #message-layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 5;
      opacity: 0;
      transition: opacity 2s cubic-bezier(0.16, 1, 0.3, 1);
      text-align: center;
      color: var(--text-color);
    }

    h1 {
      font-family: var(--font-msg);
      font-weight: 300;
      font-size: clamp(2rem, 5vw, 4rem);
      letter-spacing: -0.02em;
      margin: 0 0 20px 0;
      max-width: 800px;
      padding: 0 20px;
      line-height: 1.2;
    }

    p {
      font-family: var(--font-msg);
      font-weight: 400;
      color: #888;
      font-size: 1.1rem;
      max-width: 600px;
      line-height: 1.6;
      padding: 0 20px;
    }

    /* The Initial Prompt */
    #prompt {
      position: absolute;
      bottom: 50px;
      left: 50%;
      transform: translateX(-50%);
      color: var(--noise-color);
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 2px;
      opacity: 1;
      transition: opacity 0.5s;
      z-index: 20;
    }

    /* Distortion effects for the background when chaotic */
    #static-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: repeating-linear-gradient(0deg,
          transparent,
          transparent 2px,
          rgba(255, 255, 255, 0.05) 3px);
      pointer-events: none;
      z-index: 2;
    }

    /* Progress Bar (The Calmness Meter) */
    #calm-meter {
      position: absolute;
      top: 0;
      left: 0;
      height: 4px;
      width: 0%;
      background-color: var(--text-color);
      z-index: 100;
      transition: width 0.1s linear;
    }

    .glitch {
      animation: glitch-anim 0.3s infinite;
    }

    @keyframes glitch-anim {
      0% {
        transform: translate(-50%, -50%) skew(0deg);
      }

      20% {
        transform: translate(-52%, -48%) skew(-10deg);
      }

      40% {
        transform: translate(-48%, -52%) skew(10deg);
      }

      60% {
        transform: translate(-50%, -50%) skew(0deg);
      }

      80% {
        transform: translate(-51%, -49%) skew(5deg);
      }

      100% {
        transform: translate(-50%, -50%) skew(0deg);
      }
    }
  </style>
</head>

<body>

  <div id="calm-meter"></div>
  <div id="static-overlay"></div>

  <div id="noise-layer"></div>

  <div id="prompt">Search for the answer</div>

  <div id="message-layer">
    <h1>The noise is not the world.<br>The noise is your search for it.</h1>
    <p>
      We built a civilization optimized for processing, scrolling, and seeking.
      We forgot that clarity doesn't come from finding more data.
      It comes when the input stops.
    </p>
  </div>

  <script>
    const noiseLayer = document.getElementById('noise-layer');
    const messageLayer = document.getElementById('message-layer');
    const prompt = document.getElementById('prompt');
    const calmMeter = document.getElementById('calm-meter');

    // Chaos words representing modern digital anxiety
    const words = [
      "NOTIFICATION", "UPDATE", "URGENT", "DEADLINE", "ERROR",
      "CONNECTING...", "DATA", "CONTENT", "LIKE", "SUBSCRIBE",
      "OPTIMIZE", "FASTER", "LOADING", "MISSING OUT", "TRENDING",
      "PROFILE", "IDENTITY", "CACHE", "BUFFERING", "SYSTEM",
      "ALERT", "UPGRADE", "SYNC", "FILTER", "NETWORK"
    ];

    let chaosLevel = 0; // 0 to 100
    let lastMouseX = 0;
    let lastMouseY = 0;
    const isStill = false;
    const stillTimer = 0;
    const maxChaos = 100;
    const chaosDecay = 0.5; // How fast chaos drops when still
    const chaosGain = 2.5; // How fast chaos rises when moving
    const particles = [];

    // Audio Context for generating hum (only starts after user interaction)
    let audioCtx;
    let osc;
    let gainNode;
    let audioStarted = false;

    function initAudio() {
      if (audioStarted) return;
      const AudioContext = window.AudioContext || window.webkitAudioContext;
      if (!AudioContext) return;

      audioCtx = new AudioContext();
      osc = audioCtx.createOscillator();
      gainNode = audioCtx.createGain();

      osc.type = 'sine';
      osc.frequency.value = 100; // Low hum
      osc.connect(gainNode);
      gainNode.connect(audioCtx.destination);

      gainNode.gain.value = 0;
      osc.start();
      audioStarted = true;
    }

    function createNoiseParticle(x, y, intensity) {
      const span = document.createElement('span');
      span.classList.add('noise-particle');
      span.textContent = words[Math.floor(Math.random() * words.length)];

      // Random styling based on chaos
      const size = 10 + (Math.random() * 20 * (chaosLevel / 20));
      span.style.fontSize = `${size}px`;

      // Color shifts
      if (Math.random() > 0.8) {
        span.style.color = '#ff4d4d'; // Error red
        span.style.zIndex = 15;
      } else if (Math.random() > 0.8) {
        span.style.color = '#fff';
      }

      if (chaosLevel > 80) {
        span.classList.add('glitch');
      }

      // Random velocity
      const vx = (Math.random() - 0.5) * (chaosLevel / 5);
      const vy = (Math.random() - 0.5) * (chaosLevel / 5);

      span.style.left = `${x}px`;
      span.style.top = `${y}px`;

      noiseLayer.appendChild(span);

      particles.push({
        element: span,
        x: x,
        y: y,
        vx: vx,
        vy: vy,
        life: 1.0
      });

      // Limit particles
      if (particles.length > 150) {
        const p = particles.shift();
        p.element.remove();
      }
    }

    function updatePhysics() {
      // Decay chaos
      if (chaosLevel > 0) {
        chaosLevel -= chaosDecay;
      }
      if (chaosLevel < 0) chaosLevel = 0;

      // Update particles
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life -= 0.02;

        p.element.style.left = `${p.x}px`;
        p.element.style.top = `${p.y}px`;
        p.element.style.opacity = p.life;

        if (p.life <= 0) {
          p.element.remove();
          particles.splice(i, 1);
        }
      }

      // Visual feedback
      const normalizedChaos = chaosLevel / maxChaos;

      // Blur effect on body based on chaos
      document.body.style.backdropFilter = `blur(${normalizedChaos * 10}px)`;

      // Audio Feedback
      if (audioStarted) {
        // High pitch and volume when chaotic, low hum when calm
        const targetFreq = 60 + (normalizedChaos * 800);
        const targetGain = normalizedChaos * 0.1;

        osc.frequency.setTargetAtTime(targetFreq, audioCtx.currentTime, 0.1);
        gainNode.gain.setTargetAtTime(targetGain, audioCtx.currentTime, 0.1);
      }

      // The Reveal Logic
      if (chaosLevel < 5) {
        messageLayer.style.opacity = 1;
        prompt.style.opacity = 0;
        calmMeter.style.width = '100%';
        calmMeter.style.backgroundColor = '#4caf50'; // Green for calm
      } else {
        messageLayer.style.opacity = 0;
        prompt.style.opacity = 1;
        prompt.innerText = chaosLevel > 50 ? "TOO LOUD" : "SEARCH FOR THE ANSWER";

        // Meter goes down as chaos goes up
        const calmPercent = Math.max(0, 100 - chaosLevel);
        calmMeter.style.width = `${calmPercent}%`;
        calmMeter.style.backgroundColor = '#f0f0f0';
      }

      requestAnimationFrame(updatePhysics);
    }

    function handleInput(e) {
      if (!audioStarted) initAudio();

      let clientX, clientY;

      if (e.type.includes('touch')) {
        clientX = e.touches[0].clientX;
        clientY = e.touches[0].clientY;
      } else {
        clientX = e.clientX;
        clientY = e.clientY;
      }

      // Calculate distance moved
      const dist = Math.hypot(clientX - lastMouseX, clientY - lastMouseY);

      // If moving significantly
      if (dist > 2) {
        chaosLevel += chaosGain;
        if (chaosLevel > maxChaos) chaosLevel = maxChaos;

        // Spawn noise
        if (Math.random() < (chaosLevel / 50)) {
          createNoiseParticle(clientX, clientY);
        }
      }

      lastMouseX = clientX;
      lastMouseY = clientY;
    }

    window.addEventListener('mousemove', handleInput);
    window.addEventListener('touchmove', handleInput);
    window.addEventListener('click', () => {
      if (!audioStarted) initAudio();
      // Clicking adds a burst of chaos
      chaosLevel += 20;
      for (let i = 0; i < 5; i++) {
        createNoiseParticle(lastMouseX + (Math.random() * 40 - 20), lastMouseY + (Math.random() * 40 - 20));
      }
    });

    // Initialize loop
    updatePhysics();

  </script>
</body>

</html>