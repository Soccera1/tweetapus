<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>The Weight of the Unsaid</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Space+Mono:ital,wght@0,400;0,700;1,400&family=Inter:wght@300;400;600&display=swap');

    :root {
      --bg: #050507;
      --text-active: #e0e0e0;
      --text-ghost: #4a4a50;
      --accent: #ff3b3b;
      --debris-color: #6b7280;
    }

    body,
    html {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      background-color: var(--bg);
      overflow: hidden;
      font-family: 'Inter', sans-serif;
      cursor: crosshair;
    }

    #ui-layer {
      position: absolute;
      top: 20%;
      left: 50%;
      transform: translateX(-50%);
      width: 80%;
      max-width: 600px;
      z-index: 10;
      pointer-events: none;
    }

    #input-display {
      font-family: 'Space Mono', monospace;
      font-size: 2rem;
      color: var(--text-active);
      min-height: 3rem;
      border-right: 2px solid var(--accent);
      white-space: pre-wrap;
      animation: blink 1s infinite;
      text-shadow: 0 0 10px rgba(255, 255, 255, 0.1);
    }

    #status-label {
      margin-top: 1rem;
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 2px;
      color: var(--text-ghost);
    }

    canvas {
      display: block;
      position: absolute;
      top: 0;
      left: 0;
      z-index: 1;
    }

    .overlay-msg {
      position: absolute;
      bottom: 30px;
      right: 30px;
      color: var(--text-ghost);
      font-family: 'Space Mono', monospace;
      font-size: 12px;
      opacity: 0;
      animation: fadeIn 2s 10s forwards;
      pointer-events: none;
      z-index: 20;
    }

    @keyframes blink {

      0%,
      100% {
        border-color: transparent;
      }

      50% {
        border-color: var(--accent);
      }
    }

    @keyframes fadeIn {
      to {
        opacity: 0.6;
      }
    }
  </style>
</head>

<body>

  <canvas id="physicsCanvas"></canvas>

  <div id="ui-layer">
    <div id="status-label">Drafting message...</div>
    <div id="input-display"></div>
  </div>

  <div class="overlay-msg">
    THE TRUTH HAS MASS.
  </div>

  <script>
    /**
     * CONCEPT: THE CONSERVATION OF SEMANTIC MASS
     * 
     * We tend to think that when we backspace a thought, it disappears.
     * This visualization proposes that deleted thoughts do not vanish.
     * They become heavy debris that settles at the bottom of our consciousness.
     * 
     * The "clean" simple messages we actually send are built on top of 
     * a mountain of complex, messy, heavy truths we chose to bury.
     */

    const canvas = document.getElementById('physicsCanvas');
    const ctx = canvas.getContext('2d');
    const inputDisplay = document.getElementById('input-display');
    const statusLabel = document.getElementById('status-label');

    let width, height;
    let particles = [];

    // Physics constants
    const GRAVITY = 0.4;
    const FRICTION = 0.9; // Air resistance
    const FLOOR_BOUNCE = 0.5;
    const MOUSE_REPULSION = 150;

    // Mouse state
    const mouse = { x: -1000, y: -1000 };

    // Narrative Script
    // Format: [Type this string], [Backspace N chars], [Wait ms]
    const script = [
      { type: "I am terrif", delay: 50 },
      { backspace: 6, delay: 800 }, // Deletes "terrif"
      { type: "not sure if I can do this anymore.", delay: 50 },
      { backspace: 30, delay: 1500 }, // Deletes whole sentence
      { type: "I feel so lonely even when", delay: 60 },
      { backspace: 15, delay: 600 },
      { type: "disconnected.", delay: 80 },
      { backspace: 13, delay: 1000 },
      { type: "I need help.", delay: 100 },
      { backspace: 12, delay: 2000 },

      // The mask begins
      { type: "Hey!", delay: 100 },
      { wait: 500 },
      { type: " Just checking in.", delay: 50 },
      { wait: 1000 },
      { type: " Everything is g", delay: 80 },
      { backspace: 1, delay: 300 }, // Hesitation on 'g'
      { type: "reat.", delay: 100 },
      { wait: 2000 },

      // Round 2
      { backspace: 25, delay: 500 }, // Clear "Hey! Just checking in..."
      { type: "Do you ever wonder if we are just", delay: 40 },
      { backspace: 29, delay: 800 },
      { type: "waste of carbon?", delay: 50 },
      { backspace: 16, delay: 1200 },
      { type: "screaming into the void?", delay: 50 },
      { backspace: 24, delay: 1500 },

      // The polite mask
      { type: "Lunch was fun today.", delay: 80 },
      { wait: 2500 },

      // Round 3 - The heavy stuff
      { backspace: 20, delay: 400 },
      { type: "I love you.", delay: 150 },
      { wait: 1000 },
      { backspace: 11, delay: 2000 }, // The hardest deletion

      { type: "See you tomorrow.", delay: 100 },
      { wait: 5000 },
      { reset: true }
    ];

    // Resize handling
    function resize() {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    // Mouse tracking
    window.addEventListener('mousemove', (e) => {
      mouse.x = e.clientX;
      mouse.y = e.clientY;
    });

    // Particle Class (The Deleted Letters)
    class LetterParticle {
      constructor(char, x, y) {
        this.char = char;
        this.x = x;
        this.y = y;
        // Random velocity to simulate the "pop" of backspace
        this.vx = (Math.random() - 0.5) * 10;
        this.vy = -Math.random() * 5 - 2;
        this.rotation = (Math.random() - 0.5);
        this.angle = 0;
        this.size = 30 + Math.random() * 10;
        this.mass = 1;
        this.settled = false;
        this.color = `hsl(${Math.random() * 60 + 200}, 20%, ${Math.random() * 40 + 30}%)`; // Cold debris colors

        // Special colors for emotional words (simple heuristic)
        if ("LOVEHELPVOID".includes(char.toUpperCase())) {
          this.color = '#ff4d4d'; // Red for intensity
        }
      }

      update() {
        // Mouse Interaction (Repulsion - pushing through the debris)
        const dx = this.x - mouse.x;
        const dy = this.y - mouse.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist < MOUSE_REPULSION) {
          const force = (MOUSE_REPULSION - dist) / MOUSE_REPULSION;
          const angle = Math.atan2(dy, dx);
          this.vx += Math.cos(angle) * force * 2;
          this.vy += Math.sin(angle) * force * 2;
          this.settled = false;
        }

        if (!this.settled) {
          this.vy += GRAVITY;
          this.vx *= FRICTION;
          this.vy *= FRICTION;

          this.x += this.vx;
          this.y += this.vy;
          this.angle += this.rotation * 0.1;

          // Floor collision
          if (this.y > height - this.size) {
            this.y = height - this.size;
            this.vy *= -FLOOR_BOUNCE;
            this.vx *= 0.8; // Ground friction

            // Stop rotating when on ground
            this.rotation *= 0.5;

            // Sleep threshold
            if (Math.abs(this.vy) < 0.5 && Math.abs(this.vx) < 0.5) {
              this.settled = true;
            }
          }

          // Wall collision
          if (this.x < 0 || this.x > width) {
            this.vx *= -1;
            this.x = Math.max(0, Math.min(width, this.x));
          }
        } else {
          // Even if settled, drift slightly if disturbed by neighbors (very simple stacking simulation)
          // To keep it performant, we just let them sleep mostly
        }
      }

      draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        ctx.fillStyle = this.color;
        ctx.font = `bold ${this.size}px 'Space Mono'`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(this.char, 0, 0);
        ctx.restore();
      }
    }

    // Text Engine
    let currentText = "";
    let scriptIndex = 0;
    let charIndex = 0;
    let lastUpdate = 0;
    let state = "IDLE"; // TYPING, BACKSPACING, WAITING
    let waitEnd = 0;

    function getCoordinatesOfLastChar() {
      // Create a temporary span to measure position
      // This is a rough approximation to spawn particles near the cursor
      const rect = inputDisplay.getBoundingClientRect();
      // Calculate width roughly based on char count (monospaced helps here)
      const charWidth = 19; // Approximate width of 2rem Space Mono
      const x = rect.left + (currentText.length * charWidth);
      const y = rect.top + 20;
      return { x, y };
    }

    function spawnParticle(char) {
      const pos = getCoordinatesOfLastChar();
      particles.push(new LetterParticle(char, pos.x, pos.y));
    }

    function processScript(timestamp) {
      if (scriptIndex >= script.length) return;

      const action = script[scriptIndex];

      if (state === "IDLE") {
        if (action.type) {
          state = "TYPING";
          charIndex = 0;
        } else if (action.backspace) {
          state = "BACKSPACING";
          charIndex = 0;
        } else if (action.wait) {
          state = "WAITING";
          waitEnd = timestamp + action.wait;
        } else if (action.reset) {
          // Reset loop but keep particles
          scriptIndex = 0;
          currentText = "";
          inputDisplay.textContent = "";
          return;
        }
      }

      if (state === "WAITING") {
        if (timestamp > waitEnd) {
          state = "IDLE";
          scriptIndex++;
        }
      }
      else if (state === "TYPING") {
        if (timestamp - lastUpdate > action.delay) {
          const charToAdd = action.type[charIndex];
          currentText += charToAdd;
          inputDisplay.textContent = currentText;
          charIndex++;
          lastUpdate = timestamp;

          // Audio cues could go here

          if (charIndex >= action.type.length) {
            state = "IDLE";
            scriptIndex++;
          }
        }
      }
      else if (state === "BACKSPACING") {
        if (timestamp - lastUpdate > action.delay) {
          if (currentText.length > 0) {
            const charRemoved = currentText.slice(-1);
            currentText = currentText.slice(0, -1);
            inputDisplay.textContent = currentText;

            // THE CORE MECHANIC: Deleted words become physical objects
            spawnParticle(charRemoved);
          }

          charIndex++;
          lastUpdate = timestamp;

          if (charIndex >= action.backspace) {
            state = "IDLE";
            scriptIndex++;
          }
        }
      }
    }

    // Main Loop
    function loop(timestamp) {
      ctx.clearRect(0, 0, width, height);

      // Update and Draw Particles
      for (let i = 0; i < particles.length; i++) {
        particles[i].update();
        particles[i].draw();
      }

      // Remove particles that fell off screen (bug safety)
      particles = particles.filter(p => p.y < height + 100);

      // Handle collisions between particles (Very simple O(N^2) check for stacking effect)
      // We limit this to only checking against a few neighbors for performance
      // Or we just let them overlap to simulate "piling up" which looks messier/better for this concept

      processScript(timestamp);

      requestAnimationFrame(loop);
    }

    requestAnimationFrame(loop);

  </script>
</body>

</html>